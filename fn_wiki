#include <socket.h>
int socket( int domain, int type, int protocol );
-	create an endpoint and return its file descriptor
-	*domain* defined the communication protocol
-	*type* defined the communication semantics
-	*protocol* defined the protocol used by the socket (can be set to 0)
- 	return 0 on succes, -1 on failure

#include <socket.h>
int	gettsockopt( int sockfd, int level, int optname, void *optval, socklen_t *optlen );
-	get the info of the socket pointed by *sockfd*
-	get the info at a given *level*
- 	*optval* and *optlen* is used to return info
- 	return 0 on succes, -1 on failure

#include <socket.h>
int	setsockpot( int sockfd, int level, int optname, const void *optval, socklen_t optlen );
-	modify a socket pointed by *sockfd*
-	set the socket at a given *level*
-	modify the socket based on *optval* and *optlen*
- 	return 0 on succes, -1 on failure

#include <socket.h>
int	getsockname( int sockfd, struct sockadd *addr, socklen_t *addrlen);
-	return the current addres of the socket pointed by *sockfd* in *addr*
-	on return *addrlen* containt the size of the socket address
- 	return 0 on succes, -1 on failure

#include <netdb.h>
struct protoent	*getprotobyname( char *name );
-	return a protoent struct that match the *name*
-	return a pointer to a malloc protoent struct or NULL on failure

#include <netdb.h>
struct 	hostent *gethostbyname( char *name );
-	Obsolet function, we should use *getaddrinfo()*

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
int 	getaddrinfo( char *node,  char *service,  struct addrinfo *hints, struct addrinfo **res );
-	return one or multiple addrinfo struct based on *node* and *service*
-	return *hints* is used to specify some selection criteria, can be NULL
-	On return, *res* is a linked list of addrinfo that match *hints* criteria
-	return 0 on succes or an error code

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
void	freeaddrinfo( struct addrinfo *res );
-	free all the linked list pointed by register

#include <sys/socket.h>
int bind( int sockfd, struct sockaddr *addr, socklen_t addrlen );
-	"assign a name" to a new socket point by *sockfd*
-	affect the addres in *addr* on *sockfd*, *addrlen* been the size of the *addr* pointer
- 	return 0 on succes, -1 on failure

#include <sys/socket.h>
int connect( int sockfd, struct sockaddr *serv_addr, socklen_t addrlen );
-	connect *sockfd* to an address in *serv_addr*, *addrlen* been the size of the *serv_addr* pointer
- 	return 0 on succes, -1 on failure

#include <sys/socket.h>
int listen ( int sockfd, int backlog );
-	mark *sockfd* as n passive socket, a socket that will be used to accept incoming connection with *accept()*;
-	*backlog* is the max size of the queue of connections
- 	return 0 on succes, -1 on failure

#include <unistd.h>
int accept( int sockfd,  struct sockaddr *addr, socklen_t *len );
-	use for socket in SOCK_STREAM or SOCK_SEQPACKET mode, extract the first connection of *sockfd*, create a new connected socket
-	*sockfd* must be a socket created with *socket(2)*, attach with *bind(2)* and after a call to *listen(2)*
-	*addr* point to a sockaddr struct that will be filled with the addres of the connections
-	fail if socket is non blockant and there is 0 connections
- 	return a file descriptor to the new socket, -1 on failure

#include <arpa/inet.h>
uint32_t	htonl( uint32_t hostlong );
-	convert an unsigned long int *hostlong* from host byte order to network byter order

#include <arpa/inet.h>
uint16_t	htons( uint16_t hostshort );
-	convert an unsigned short int *hostshort* from host byte order to network byter order

#include <arpa/inet.h>
uint32_t	ntohl( uint32_t netlong );
-	convert an unsigned  int *netlong* from network byter order to host byte order

#include <arpa/inet.h>
uint16_t ntohs( uint16_t netshort );
-	convert an unsigned short int *netshort* from network byter order to host byte order

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
in_addr_t inet_addr(const char *cp);
-	convert an IPV4 addres in string into binary data in network byte order, return INADDR_NONE on failure, usually -1
-	its better to not use this function cause -1 is  a valid address(255.255.255.255), prefer *getaddrinfo()*

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
char *inet_ntoa(struct in_addr in);
-	convert *in*, an internet host address in network byte order to a string

#include <sys/types.h>
#include <sys/socket.h>
ssize_t send( int s, const void *buf, size_t len, int flags );
-	transmit a message to a connected socket, *send()* is just *write(2)* with more flags
-	*s* is the sending socket
-	*len* is the size of *buf*
- 	return the number of char send, -1 on failure


#include <sys/types.h>
#include <sys/socket.h>
ssize_t recv( int s, void *buf, ssize_t len, int flags );
-	recv is used on connected socket
-	if the message received is too long, data can be loss
-	syscall *select(2)* or *poll(2)* can be used to determine if there is still data to be received
-	return the len of the message receive, 0 on a normal exit, -1 on failure

#include <sys/types.h>
#include <unistd.h>
off_t lseek( int fd, off_t offset, int whence );
-	offset the head of *fd* by *offset*
-	return the offset on succes, -1 on failure

#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock *lock);
-	use to perfom certain operation of *fd* like duplicate the *fd*, read the description of the *fd*,...
-	return the result of the operation, -1 on failure

#include <poll.h>
int poll( struct pollfd *fds, nfds_t nfds, int delay );
-	the function wait for an fd in *fds* to be ready for input/output
-	wait for *delay* in millisecond, if *delay* is < 0, wait indefinitely
-	return the number of struct having a non null renvts field ,0 if nothing appened,  -1 on failur

# We can use *poll()* or *select()*, *kqueue()*, *epoll()* #